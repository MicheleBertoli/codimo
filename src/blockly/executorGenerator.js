/**
 * @author Luciano Graziani @lgraziani2712
 * @license {@link http://www.opensource.org/licenses/mit-license.php|MIT License}
 *
 * This tester must evaluate every component.
 *
 * @flow
 */

// FIXME This function need to be more generic
// Right now only works for one specific function
function componentExecutionConfig(blockName: string) {
  // FIXME hardcoded 0
  Blockly.JavaScript[blockName] = () => (`0,${blockName};`);
}

export type ActorsToActions = Map<number, Array<string>>;
export type Executor = {|
  addBlockExecutor(blockName: string): void,
  parseInstructions(code: string): ActorsToActions,
|};
/**
 * This object is responsible for executing the code-as-string generated by blockly.
 * It allows to add every function used by each block.
 *
 * @return {Object} excecutor
 */
const executorGenerator = (): Executor => ({
  addBlockExecutor(blockName: string) {
    componentExecutionConfig(blockName);
  },
  /**
   * Each instruction follows this format:
   *      actor,action;
   * Where the semicolon is the separator.
   *
   * @param  {string} rawInstructions a sequence of raw instructions
   * @return {ActorsToActions}        a map with sequence of actions for each actor
   */
  parseInstructions: (rawInstructions: string): ActorsToActions => {
    const splittedRawInstructions = rawInstructions.split(';');
    const instructions = new Map();
    let actions;

    // Deletes the last & empty value
    splittedRawInstructions.pop();

    splittedRawInstructions.forEach((splittedRawInstruction) => {
      const elements = splittedRawInstruction.split(',');
      const key = parseInt(elements[0]);

      actions = instructions.get(key) || [];
      actions.push(elements[1]);

      instructions.set(key, actions);
    });

    return instructions;
  },
});

export default executorGenerator;
